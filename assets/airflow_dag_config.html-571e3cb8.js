import{_ as s,Y as l,Z as c,$ as r,a0 as e,a1 as a,a2 as t,a4 as o,E as i}from"./framework-957baa9a.js";const d={},p=e("h1",{id:"airflow-配置踩坑说明",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#airflow-配置踩坑说明","aria-hidden":"true"},"#"),a(" Airflow | 配置踩坑说明")],-1),u=e("blockquote",null,[e("p",null,[a("airflow dag 配置常见问题, 尽量禁用"),e("code",null,"Catchup")])],-1),h=e("p",null,"刚提交的dag在达到临近的第一次执行时间时为什么没有执行?",-1),_={href:"https://airflow.apache.org/docs/apache-airflow/1.10.1/scheduler.html",target:"_blank",rel:"noopener noreferrer"},f=o("<blockquote><p>Let’s Repeat That The scheduler runs your job one schedule_interval AFTER the start date, at the END of the period.</p></blockquote><p>Airflow 调度器监控所有的任务和dag, 并在条件满足时触发任务实例, 生效Dag后, 调度器将会根据start_date创建任务实例, 生成下一次的执行计划.</p><p>比如: 有一个每周二执行的任务, <code>1 8 * * * 2</code>, 如果<code>2023-05-17</code>(周三)生效了dag, 并且<code>start_date=2023-05-17</code>, 那么将会在<code>2023-05-23</code>调度器调度生成任务, 此任务在<code>2023-05-30</code>执行. 所以至少要设置<code>start_date=2023-05-15</code>, 为了避免频繁计算, 安全设置方式: <code>start_date=now - datetime.timedelta(schedule_interval)</code></p>",3),k=e("p",null,"airflow 启动dag后, 为什么补跑了很多历史任务?",-1),m=e("p",null,[a("当"),e("code",null,"catchup=True"),a("时, 文档提到在关闭的dag重新开启, 还会执行之前的任务, 这通常不符合我们的需求, 并且有些时候是危险的, 所以需要特别关注并关闭配置")],-1),g={href:"https://airflow.apache.org/docs/apache-airflow/2.6.0/core-concepts/dag-run.html#catchup",target:"_blank",rel:"noopener noreferrer"},v=o(`<blockquote><p>So, Catchup is also triggered when you turn off a DAG for a specified period and then re-enable it.</p></blockquote><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>    dag <span class="token operator">=</span> DAG<span class="token punctuation">(</span>
        dag_id<span class="token operator">=</span>DAG_ID<span class="token punctuation">,</span>
        default_args<span class="token operator">=</span>default_args<span class="token punctuation">,</span>
        schedule_interval<span class="token operator">=</span>CRON<span class="token punctuation">,</span>
        start_date<span class="token operator">=</span>utc_logic_start_date<span class="token punctuation">,</span>
        tags<span class="token operator">=</span><span class="token punctuation">[</span>PROJECT<span class="token punctuation">]</span><span class="token punctuation">,</span>
        catchup<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),b=e("p",null,"结合以上两点, 确保airflow禁用Catchup后, start_date可以设置的比较靠前",-1);function w(A,x){const n=i("ExternalLinkIcon");return l(),c("div",null,[p,u,r(" more "),e("ol",null,[e("li",null,[h,e("p",null,[a("参考: "),e("a",_,[a("Scheduling & Triggers"),t(n)])]),f]),e("li",null,[k,m,e("blockquote",null,[e("p",null,[a("A key capability of Airflow is that these DAG Runs are atomic, idempotent items, and the scheduler, by default, will examine the lifetime of the DAG (from start to end/now, one interval at a time) and kick off a DAG Run for any interval that has not been run (or has been cleared). This concept is called "),e("a",g,[a("Catchup"),t(n)]),a(".")])]),v])]),b])}const D=s(d,[["render",w],["__file","airflow_dag_config.html.vue"]]);export{D as default};
