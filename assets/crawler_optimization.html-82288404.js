import{_ as o,Y as n,Z as r,a0 as l,a1 as e,a2 as t,a4 as a,E as s}from"./framework-957baa9a.js";const c={},_=l("h1",{id:"爬虫优化",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#爬虫优化","aria-hidden":"true"},"#"),e(" 爬虫优化")],-1),u=a("<li><p>并发爬虫</p><ol><li>多线程</li><li>多进程</li><li>concurrent.futures</li><li>asyncio</li></ol></li><li><p>使用连接池(urllib3)</p><ul><li>实现了连接池和支持数据的压缩</li><li>为什么要使用连接池呢？ 保持链接可以节省网络链接的时间和资源</li></ul></li><li><p>开启gzip</p></li><li><p>使用消息队列</p></li>",4),p=l("p",null,"布隆过滤器(Bloom Filter)",-1),d=l("li",null,"scrapy使用了",-1),h={href:"https://llimllib.github.io/bloomfilter-tutorial/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://blog.csdn.net/bone_ace/article/details/53107018",target:"_blank",rel:"noopener noreferrer"},m=l("li",null,[l("p",null,"熟悉抓取相关框架的参数")],-1),b=l("li",null,[l("p",null,"批量存到数据库")],-1),x=l("li",null,[l("p",null,"设置请求超时时间")],-1);function k(g,B){const i=s("ExternalLinkIcon");return n(),r("div",null,[_,l("ol",null,[u,l("li",null,[p,l("ul",null,[d,l("li",null,[l("a",h,[e("参考链接"),t(i)])]),l("li",null,[l("a",f,[e("结合redis的去重"),t(i)])])])]),m,b,x])])}const N=o(c,[["render",k],["__file","crawler_optimization.html.vue"]]);export{N as default};
